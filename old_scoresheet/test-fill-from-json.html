<!DOCTYPE html>
<html>
<head>
  <title>Test: Fill PDF from Scoreboard JSON</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      padding: 20px;
      max-width: 1000px;
      margin: 0 auto;
    }
    textarea {
      width: 100%;
      height: 200px;
      font-family: monospace;
      font-size: 12px;
      padding: 10px;
      border: 1px solid #ccc;
      border-radius: 4px;
    }
    button {
      padding: 10px 20px;
      font-size: 16px;
      cursor: pointer;
      margin: 10px 5px;
      background: #007bff;
      color: white;
      border: none;
      border-radius: 4px;
    }
    button:hover {
      background: #0056b3;
    }
    button:disabled {
      background: #ccc;
      cursor: not-allowed;
    }
    .section {
      margin: 20px 0;
      padding: 15px;
      background: #f5f5f5;
      border-radius: 4px;
    }
    .info {
      background: #e3f2fd;
      padding: 15px;
      border-radius: 4px;
      margin: 10px 0;
    }
    .error {
      background: #ffebee;
      color: #c62828;
      padding: 15px;
      border-radius: 4px;
      margin: 10px 0;
    }
    .success {
      background: #e8f5e9;
      color: #2e7d32;
      padding: 15px;
      border-radius: 4px;
      margin: 10px 0;
    }
    pre {
      background: #fff;
      padding: 10px;
      border-radius: 4px;
      overflow-x: auto;
      max-height: 300px;
      overflow-y: auto;
    }
    input[type="file"] {
      margin: 10px 0;
    }
  </style>
</head>
<body>
  <h1>Test: Fill PDF from Scoreboard JSON</h1>
  
  <div class="info">
    <p><strong>Instructions:</strong></p>
    <ol>
      <li>Make sure <code>matchblatt_fillable.pdf</code> is in the same folder</li>
      <li>First, click "Extract PDF Fields" to create the mapping file (one-time setup)</li>
      <li>Then paste your database export JSON or upload the file</li>
      <li>Click "Fill PDF" to generate the filled scoresheet</li>
    </ol>
  </div>

  <div class="section">
    <h2>Step 0: Extract PDF Fields (One-time setup)</h2>
    <p>First, extract all form fields from the fillable PDF to create the mapping file:</p>
    <button id="extractBtn">Extract PDF Fields</button>
    <div id="extractOutput"></div>
  </div>

  <div class="section">
    <h2>1. Input Match Data</h2>
    <p>Paste your database export JSON here or upload the file:</p>
    <input type="file" id="jsonFile" accept=".json" />
    <textarea id="jsonInput" placeholder='Paste your database export JSON here (from debugExportMatchData or database export file)'></textarea>
  </div>

  <div class="section">
    <h2>2. Additional Data (Optional)</h2>
    <p>If your JSON doesn't include referees/scorers, you can add them here:</p>
    <textarea id="additionalData" placeholder='{
  "referees": [
    { "role": "ref1", "firstName": "Hans", "lastName": "Müller" },
    { "role": "ref2", "firstName": "Peter", "lastName": "Schmidt" }
  ],
  "scorers": [
    { "role": "scorer", "firstName": "Anna", "lastName": "Weber" },
    { "role": "asst-scorer", "firstName": "Lisa", "lastName": "Fischer" }
  ]
}'></textarea>
  </div>

  <div class="section">
    <button id="fillBtn" disabled>Fill PDF</button>
    <button id="previewBtn" disabled>Preview Transformed Data</button>
    <div id="output"></div>
  </div>

  <script type="module">
    // Import pdf-lib using ES module import (non-minified for better compatibility)
    let PDFDocument = null;
    
    // Load the fillPdfForm function (we'll include it inline for this test)
    // In production, you'd import it: import { fillPdfForm } from './src/utils/fillPdfForm.js'
    
    // For now, we'll need to include the fillPdfForm logic or load it
    // Let's create a simplified version that uses the mapping
    
    let scoreboardData = null;
    let fieldMapping = null;
    
    // Helper to ensure PDFDocument is loaded
    async function ensurePdfLib() {
      if (!PDFDocument) {
        try {
          // Try importing from skypack which handles ES modules better
          console.log('Loading pdf-lib from skypack...');
          const pdfLib = await import('https://cdn.skypack.dev/pdf-lib@1.17.1');
          console.log('Import successful, keys:', Object.keys(pdfLib));
          
          // pdf-lib exports PDFDocument as a named export
          if (pdfLib.PDFDocument) {
            PDFDocument = pdfLib.PDFDocument;
            console.log('Found PDFDocument as named export');
          } else if (pdfLib.default) {
            if (pdfLib.default.PDFDocument) {
              PDFDocument = pdfLib.default.PDFDocument;
              console.log('Found PDFDocument in default.PDFDocument');
            } else if (typeof pdfLib.default.load === 'function') {
              PDFDocument = pdfLib.default;
              console.log('Using default as PDFDocument');
            }
          }
          
          // If still not found, try jsdelivr
          if (!PDFDocument) {
            console.log('Trying jsdelivr...');
            const pdfLib2 = await import('https://cdn.jsdelivr.net/npm/pdf-lib@1.17.1/dist/pdf-lib.esm.min.js');
            console.log('jsdelivr keys:', Object.keys(pdfLib2));
            
            if (pdfLib2.PDFDocument) {
              PDFDocument = pdfLib2.PDFDocument;
            } else if (pdfLib2.default?.PDFDocument) {
              PDFDocument = pdfLib2.default.PDFDocument;
            }
          }
          
          if (!PDFDocument || typeof PDFDocument.load !== 'function') {
            throw new Error('PDFDocument.load is not a function');
          }
          
          console.log('PDFDocument loaded successfully!');
        } catch (e) {
          console.error('Error loading pdf-lib:', e);
          throw new Error(`Failed to load PDF-lib: ${e.message}. Please check your internet connection.`);
        }
      }
      
      return PDFDocument;
    }

    // Load field mapping on page load (optional)
    async function loadFieldMapping() {
      try {
        const response = await fetch('pdf-field-mapping.json');
        if (!response.ok) {
          // File doesn't exist yet - that's okay, user can extract fields
          return;
        }
        fieldMapping = await response.json();
        document.getElementById('output').innerHTML = '<p class="success">✓ Field mapping loaded successfully!</p>';
        updateButtonStates();
      } catch (error) {
        // Silently fail - user can extract fields using the button
        console.log('No existing mapping file found. Click "Extract PDF Fields" to create one.');
      }
    }

    // Transform database export format to fillable PDF format
    function transformScoreboardData(exportData) {
      // Handle database export format (with separate arrays)
      let data;
      if (exportData.matches && exportData.matches.length > 0) {
        // This is the database export format
        const match = exportData.matches[0];
        const homeTeamId = match.homeTeamId;
        const awayTeamId = match.awayTeamId;
        const homeTeam = exportData.teams?.find(t => t.id === homeTeamId) || {};
        const awayTeam = exportData.teams?.find(t => t.id === awayTeamId) || {};
        const homePlayers = exportData.players?.filter(p => p.teamId === homeTeamId) || [];
        const awayPlayers = exportData.players?.filter(p => p.teamId === awayTeamId) || [];
        const referees = exportData.referees || [];
        const scorers = exportData.scorers || [];
        
        // Merge officials from match.officials if available
        if (match.officials && Array.isArray(match.officials)) {
          match.officials.forEach(official => {
            if (official.role === '1st referee' || official.role === 'ref1') {
              if (!referees.find(r => r.role === 'ref1')) {
                referees.push({
                  role: 'ref1',
                  firstName: official.firstName,
                  lastName: official.lastName
                });
              }
            } else if (official.role === '2nd referee' || official.role === 'ref2') {
              if (!referees.find(r => r.role === 'ref2')) {
                referees.push({
                  role: 'ref2',
                  firstName: official.firstName,
                  lastName: official.lastName
                });
              }
            } else if (official.role === 'scorer') {
              if (!scorers.find(s => s.role === 'scorer')) {
                scorers.push({
                  role: 'scorer',
                  firstName: official.firstName,
                  lastName: official.lastName
                });
              }
            } else if (official.role === 'assistant scorer' || official.role === 'asst-scorer') {
              if (!scorers.find(s => s.role === 'asst-scorer')) {
                scorers.push({
                  role: 'asst-scorer',
                  firstName: official.firstName,
                  lastName: official.lastName
                });
              }
            }
          });
        }
        
        data = {
          match: match,
          homeTeam: homeTeam,
          awayTeam: awayTeam,
          homePlayers: homePlayers,
          awayPlayers: awayPlayers,
          referees: referees,
          scorers: scorers
        };
      } else {
        // Assume it's already in the expected format
        data = exportData;
      }
      // Format date as dd.mm.yyyy
      function formatDate(dateString) {
        if (!dateString) return '';
        const date = new Date(dateString);
        const day = String(date.getDate()).padStart(2, '0');
        const month = String(date.getMonth() + 1).padStart(2, '0');
        const year = date.getFullYear();
        return `${day}.${month}.${year}`;
      }

      // Format time as HH:mm
      function formatTime(dateString) {
        if (!dateString) return '';
        const date = new Date(dateString);
        const hours = String(date.getHours()).padStart(2, '0');
        const minutes = String(date.getMinutes()).padStart(2, '0');
        return `${hours}:${minutes}`;
      }

      // Transform players
      const transformPlayers = (players) => {
        if (!players || !Array.isArray(players)) return [];
        return players.map(p => ({
          number: p.number,
          name: p.name || `${p.lastName || ''} ${p.firstName || ''}`.trim(),
          firstName: p.firstName,
          lastName: p.lastName,
          dob: p.dob ? (p.dob.includes('/') ? p.dob.replace(/\//g, '.') : p.dob) : ''
        }));
      };

      // Get liberos
      const getLiberos = (players) => {
        if (!players || !Array.isArray(players)) return [];
        return players
          .filter(p => p.libero && p.libero !== '')
          .map(p => ({
            number: p.number,
            name: p.name || `${p.lastName || ''} ${p.firstName || ''}`.trim(),
            firstName: p.firstName,
            lastName: p.lastName,
            dob: p.dob ? (p.dob.includes('/') ? p.dob.replace(/\//g, '.') : p.dob) : ''
          }));
      };

      // Transform bench
      const transformBench = (bench) => {
        if (!bench || !Array.isArray(bench)) return [];
        return bench.map(b => ({
          role: b.role || 'coach',
          firstName: b.firstName,
          lastName: b.lastName,
          name: b.name || `${b.lastName || ''} ${b.firstName || ''}`.trim(),
          dob: b.dob ? (b.dob.includes('/') ? b.dob.replace(/\//g, '.') : b.dob) : ''
        }));
      };

      const match = data.match || {};
      const homeTeam = data.homeTeam || {};
      const awayTeam = data.awayTeam || {};
      const homePlayers = data.homePlayers || [];
      const awayPlayers = data.awayPlayers || [];
      const referees = data.referees || [];
      const scorers = data.scorers || [];

      return {
        match: {
          scheduledAt: match.scheduledAt,
          date: formatDate(match.scheduledAt),
          time: formatTime(match.scheduledAt),
          venue: match.venue || match.hall || '',
          city: match.city || '',
          league: match.league || '',
          gameNumber: match.gameNumber || match.externalId || match.game_n || '',
          matchType: match.matchType || match.match_type_1 || 'championship'
        },
        homeTeam: {
          name: homeTeam.name || ''
        },
        awayTeam: {
          name: awayTeam.name || ''
        },
        players: {
          home: transformPlayers(homePlayers),
          away: transformPlayers(awayPlayers)
        },
        liberos: {
          home: getLiberos(homePlayers),
          away: getLiberos(awayPlayers)
        },
        bench: {
          home: transformBench(match.bench_home),
          away: transformBench(match.bench_away)
        },
        officials: {
          referee1: referees.find(r => r.role === 'ref1') || referees[0] || {},
          referee2: referees.find(r => r.role === 'ref2') || referees[1] || {},
          scorer: scorers.find(s => s.role === 'scorer') || scorers[0] || {},
          assistantScorer: scorers.find(s => s.role === 'asst-scorer') || scorers[1] || {}
        }
      };
    }

    // Load fillPdfForm from the actual file
    async function loadFillPdfForm() {
      try {
        // Try to load the actual fillPdfForm.js
        const response = await fetch('src/utils/fillPdfForm.js');
        if (response.ok) {
          const code = await response.text();
          // Create a function from the code (simplified - in production use proper module import)
          // For now, we'll use a fetch-based approach
          return true;
        }
      } catch (e) {
        console.warn('Could not load fillPdfForm.js directly, will use inline version');
      }
      return false;
    }

    // Simplified fill function matching the Python implementation exactly
    async function fillPdfForm(pdfDoc, fieldMapping, matchData) {
      const form = pdfDoc.getForm();
      
      console.log('=== Filling PDF Form (Python-compatible) ===');
      
      // Helper functions
      function formatDate(dateString) {
        if (!dateString) return '';
        try {
          const date = new Date(dateString);
          const day = String(date.getDate()).padStart(2, '0');
          const month = String(date.getMonth() + 1).padStart(2, '0');
          const year = date.getFullYear();
          return `${day}.${month}.${year}`;
        } catch {
          return dateString;
        }
      }

      function formatTime(dateString) {
        if (!dateString) return '';
        try {
          const date = new Date(dateString);
          const hours = String(date.getHours()).padStart(2, '0');
          const minutes = String(date.getMinutes()).padStart(2, '0');
          return `${hours}:${minutes}`;
        } catch {
          return '';
        }
      }

      function formatDob(dobString) {
        if (!dobString) return '';
        if (dobString.includes('/')) {
          return dobString.replace(/\//g, '.');
        }
        return dobString;
      }

      function getField(fieldName) {
        try {
          return form.getTextField(fieldName);
        } catch {
          return null;
        }
      }

      function setField(fieldName, value) {
        const field = getField(fieldName);
        if (field && value !== undefined && value !== null) {
          field.setText(String(value));
          console.log(`✓ ${fieldName}: ${value}`);
          return true;
        }
        return false;
      }

      let fieldsSet = 0;

      // Match type checkboxes
      const matchTypeMapping = {
        'championship': 'championship_x',
        'cup': 'cup_x',
        'friendly': 'friendly_x',
        'tournament': 'tournament_x'
      };

      const matchType1 = matchData.match_type_1 || matchData.match?.matchType || '';
      if (matchType1 && matchTypeMapping[matchType1]) {
        if (setField(matchTypeMapping[matchType1], 'X')) fieldsSet++;
      }

      // Category checkboxes
      const categoryMapping = {
        'men': 'men_x',
        'female': 'female_x',
        'U19': 'U19_x',
        'U17': 'U17_x',
        'U23': 'U23_x'
      };

      const matchType2 = matchData.match_type_2 || matchData.match?.category || '';
      if (matchType2 && categoryMapping[matchType2]) {
        if (setField(categoryMapping[matchType2], 'X')) fieldsSet++;
      }

      // Basic match information
      const league = matchData.league || matchData.match?.league || '';
      const gameNumber = String(matchData.gameNumber || matchData.match?.gameNumber || matchData.match?.externalId || '');
      const homeTeam = matchData.homeTeam || matchData.homeTeam?.name || '';
      const awayTeam = matchData.awayTeam || matchData.awayTeam?.name || '';
      const city = matchData.city || matchData.match?.city || '';
      const hall = matchData.hall || matchData.venue || matchData.match?.venue || matchData.match?.hall || '';
      const scheduledAt = matchData.scheduledAt || matchData.match?.scheduledAt || '';

      if (setField('liga_text', league)) fieldsSet++;
      if (setField('match_n', gameNumber)) fieldsSet++;
      if (setField('home_team', homeTeam)) fieldsSet++;
      if (setField('away_team', awayTeam)) fieldsSet++;
      if (setField('city', city)) fieldsSet++;
      if (setField('hall', hall)) fieldsSet++;
      if (setField('date', formatDate(scheduledAt))) fieldsSet++;
      if (setField('time', formatTime(scheduledAt))) fieldsSet++;

      // Short team names
      const homeTeamShort = homeTeam.substring(0, 3).toUpperCase();
      const awayTeamShort = awayTeam.substring(0, 3).toUpperCase();
      if (setField('home_team_short', homeTeamShort)) fieldsSet++;
      if (setField('away_team_short', awayTeamShort)) fieldsSet++;

      // Home team bench
      const benchHome = matchData.bench_home || matchData.match?.bench_home || [];
      benchHome.forEach(person => {
        const role = person.role || '';
        const firstName = person.firstName || '';
        const lastName = person.lastName || '';
        const dob = formatDob(person.dob || '');
        const fullName = `${firstName} ${lastName}`.trim();

        if (role === 'Coach') {
          if (setField('home_roster_coach_name', fullName)) fieldsSet++;
          if (setField('home_roster_coach_dob', dob)) fieldsSet++;
        } else if (role === 'Assistant Coach 1') {
          if (setField('home_roster_ac1_name', fullName)) fieldsSet++;
          if (setField('home_roster_ac1_dob', dob)) fieldsSet++;
        } else if (role === 'Assistant Coach 2') {
          if (setField('home_roster_ac2_name', fullName)) fieldsSet++;
          if (setField('home_roster_ac2_dob', dob)) fieldsSet++;
        } else if (role === 'Physiotherapist') {
          if (setField('home_roster_p_name', fullName)) fieldsSet++;
          if (setField('home_roster_p_dob', dob)) fieldsSet++;
        } else if (role === 'Medical') {
          if (setField('home_roster_m_name', fullName)) fieldsSet++;
          if (setField('home_roster_m_dob', dob)) fieldsSet++;
        }
      });

      // Away team bench
      const benchAway = matchData.bench_away || matchData.match?.bench_away || [];
      benchAway.forEach(person => {
        const role = person.role || '';
        const firstName = person.firstName || '';
        const lastName = person.lastName || '';
        const dob = formatDob(person.dob || '');
        const fullName = `${firstName} ${lastName}`.trim();

        if (role === 'Coach') {
          if (setField('away_roster_coach_name', fullName)) fieldsSet++;
          if (setField('away_roster_coach_dob', dob)) fieldsSet++;
        } else if (role === 'Assistant Coach 1') {
          if (setField('away_roster_ac1_name', fullName)) fieldsSet++;
          if (setField('away_roster_ac1_dob', dob)) fieldsSet++;
        } else if (role === 'Assistant Coach 2') {
          if (setField('away_roster_ac2_name', fullName)) fieldsSet++;
          if (setField('away_roster_ac2_dob', dob)) fieldsSet++;
        } else if (role === 'Physiotherapist') {
          if (setField('away_roster_p_name', fullName)) fieldsSet++;
          if (setField('away_roster_p_dob', dob)) fieldsSet++;
        } else if (role === 'Medical') {
          if (setField('away_roster_m_name', fullName)) fieldsSet++;
          if (setField('away_roster_m_dob', dob)) fieldsSet++;
        }
      });

      // Officials
      const officials = matchData.officials || matchData.match?.officials || [];
      officials.forEach(official => {
        const role = official.role || '';
        const firstName = official.firstName || '';
        const lastName = official.lastName || '';
        const country = official.country || '';
        const dob = formatDob(official.dob || '');
        const fullName = `${firstName} ${lastName}`.trim();

        if (role === '1st referee') {
          if (setField('1_referee_name', fullName)) fieldsSet++;
          if (setField('1_referee_country', country)) fieldsSet++;
          if (setField('1_referee_dob', dob)) fieldsSet++;
        } else if (role === '2nd referee') {
          if (setField('2_referee_name', fullName)) fieldsSet++;
          if (setField('2_referee_country', country)) fieldsSet++;
          if (setField('2_referee_dob', dob)) fieldsSet++;
        } else if (role === 'scorer') {
          if (setField('scorer_name', fullName)) fieldsSet++;
          if (setField('scorer_country', country)) fieldsSet++;
          if (setField('scorer_dob', dob)) fieldsSet++;
        } else if (role === 'assistant scorer') {
          if (setField('ass_scorer_name', fullName)) fieldsSet++;
          if (setField('ass_scorer_country', country)) fieldsSet++;
          if (setField('ass_scorer_dob', dob)) fieldsSet++;
        }
      });

      console.log(`\n✓ Total fields set: ${fieldsSet}`);
      
      return pdfDoc;
      
      // OLD CODE COMMENTED OUT BELOW
      function formatDate(dateString) {
        if (!dateString) return '';
        const date = new Date(dateString);
        const day = String(date.getDate()).padStart(2, '0');
        const month = String(date.getMonth() + 1).padStart(2, '0');
        const year = date.getFullYear();
        return `${day}.${month}.${year}`;
      }

      function formatTime(dateString) {
        if (!dateString) return '';
        const date = new Date(dateString);
        const hours = String(date.getHours()).padStart(2, '0');
        const minutes = String(date.getMinutes()).padStart(2, '0');
        return `${hours}:${minutes}`;
      }

      function extractRowNumber(fieldName) {
        const match = fieldName.match(/_(\d+)$/);
        return match ? parseInt(match[1]) : null;
      }

      // Fill roster fields helper
      function fillRosterFields(fields, players, maxRows) {
        if (!players || players.length === 0) {
          console.log(`No players to fill (maxRows: ${maxRows})`);
          return;
        }
        
        console.log(`Filling ${players.length} players into ${maxRows} rows`);
        
        const dobFields = fields.filter(f => {
          const name = f.getName().toLowerCase();
          return name.includes('dob') && !name.includes('coach') && !name.includes('assistant') && 
                 !name.includes('physio') && !name.includes('doctor') && !name.includes('trainer');
        }).sort((a, b) => {
          const numA = extractRowNumber(a.getName());
          const numB = extractRowNumber(b.getName());
          if (numA !== null && numB !== null) return numA - numB;
          if (numA !== null) return -1;
          if (numB !== null) return 1;
          return 0;
        });
        
        const numberFields = fields.filter(f => {
          const name = f.getName().toLowerCase();
          return name.includes('number') && !name.includes('game') && !name.includes('spiel') &&
                 !name.includes('game_n');
        }).sort((a, b) => {
          const numA = extractRowNumber(a.getName());
          const numB = extractRowNumber(b.getName());
          if (numA !== null && numB !== null) return numA - numB;
          if (numA !== null) return -1;
          if (numB !== null) return 1;
          return 0;
        });
        
        const nameFields = fields.filter(f => {
          const name = f.getName().toLowerCase();
          return name.includes('name') && !name.includes('coach') && !name.includes('assistant') && 
                 !name.includes('physio') && !name.includes('doctor') && !name.includes('trainer') &&
                 !name.includes('team');
        }).sort((a, b) => {
          const numA = extractRowNumber(a.getName());
          const numB = extractRowNumber(b.getName());
          if (numA !== null && numB !== null) return numA - numB;
          if (numA !== null) return -1;
          if (numB !== null) return 1;
          return 0;
        });

        console.log(`Found fields - DOB: ${dobFields.length}, Number: ${numberFields.length}, Name: ${nameFields.length}`);
        
        const rowsToFill = Math.min(players.length, maxRows, dobFields.length, numberFields.length, nameFields.length);
        console.log(`Will fill ${rowsToFill} rows`);
        
        for (let i = 0; i < rowsToFill; i++) {
          const player = players[i];
          let dob = player.dob || '';
          if (dob && dob.includes('/')) dob = dob.replace(/\//g, '.');
          const number = String(player.number || '');
          const name = player.name || `${player.lastName || ''} ${player.firstName || ''}`.trim();
          
          try {
            if (dobFields[i]) {
              const field = dobFields[i];
              if (field.constructor.name === 'PDFTextField') {
                field.setText(dob);
                console.log(`Filled DOB field ${i}: ${dob}`);
              }
            }
            if (numberFields[i]) {
              const field = numberFields[i];
              if (field.constructor.name === 'PDFTextField') {
                field.setText(number);
                console.log(`Filled Number field ${i}: ${number}`);
              }
            }
            if (nameFields[i]) {
              const field = nameFields[i];
              if (field.constructor.name === 'PDFTextField') {
                field.setText(name);
                console.log(`Filled Name field ${i}: ${name}`);
              }
            }
          } catch (error) {
            console.error(`Error filling row ${i}:`, error);
          }
        }
      }

      // Fill player rosters
      ['home', 'away'].forEach(team => {
        const teamFields = fields.filter(f => {
          const name = f.getName().toLowerCase();
          return name.includes('roster') && name.includes('player') && name.includes(team);
        });
        console.log(`${team} team player fields found: ${teamFields.length}`);
        if (teamFields.length > 0) {
          console.log(`Sample ${team} player field names:`, teamFields.slice(0, 5).map(f => f.getName()));
          const players = team === 'home' 
            ? (matchData.players?.home || [])
            : (matchData.players?.away || []);
          console.log(`${team} team players: ${players.length}`, players.slice(0, 3).map(p => ({name: p.name || p.number, dob: p.dob})));
          fillRosterFields(teamFields, players, 14);
        } else {
          console.warn(`No ${team} player roster fields found! Looking for fields with 'roster' and 'player' and '${team}'`);
          // Debug: show all roster-related fields
          const allRosterFields = fields.filter(f => {
            const name = f.getName().toLowerCase();
            return name.includes('roster');
          });
          console.log(`All roster fields (${allRosterFields.length}):`, allRosterFields.slice(0, 10).map(f => f.getName()));
        }
      });

      // Fill libero rosters
      ['home', 'away'].forEach(team => {
        const liberoFields = fields.filter(f => {
          const name = f.getName().toLowerCase();
          return name.includes('roster') && name.includes('libero') && name.includes(team);
        });
        console.log(`${team} team libero fields found: ${liberoFields.length}`, liberoFields.map(f => f.getName()));
        if (liberoFields.length > 0) {
          const liberos = team === 'home'
            ? (matchData.liberos?.home || [])
            : (matchData.liberos?.away || []);
          console.log(`${team} team liberos: ${liberos.length}`);
          fillRosterFields(liberoFields, liberos, 2);
        } else {
          console.log(`No ${team} libero fields found (this is okay if there are no libero fields)`);
        }
      });

      // Fill bench officials
      ['home', 'away'].forEach(team => {
        const bench = team === 'home'
          ? (matchData.bench?.home || [])
          : (matchData.bench?.away || []);
        
        bench.forEach(official => {
          const role = official.role || 'coach';
          const roleMap = {
            'coach': 'coach',
            'assistant coach 1': 'assistant_coach',
            'assistant coach': 'assistant_coach',
            'physiotherapist': 'physiotherapist',
            'doctor': 'doctor',
            'trainer': 'trainer'
          };
          const roleKey = roleMap[role.toLowerCase()] || role.toLowerCase().replace(/\s+/g, '_');
          
          const dobField = fields.find(f => {
            const name = f.getName().toLowerCase();
            return name.includes('roster') && name.includes(roleKey) && 
                   name.includes(team) && name.includes('dob') && 
                   !name.match(/_(\d+)$/);
          });
          
          const nameField = fields.find(f => {
            const name = f.getName().toLowerCase();
            return name.includes('roster') && name.includes(roleKey) && 
                   name.includes(team) && name.includes('name') && 
                   !name.match(/_(\d+)$/);
          });
          
          let dob = official.dob || '';
          if (dob && dob.includes('/')) dob = dob.replace(/\//g, '.');
          const name = official.name || `${official.lastName || ''} ${official.firstName || ''}`.trim();
          
          if (dobField && dobField.constructor.name === 'PDFTextField') {
            dobField.setText(dob);
          }
          if (nameField && nameField.constructor.name === 'PDFTextField') {
            nameField.setText(name);
          }
        });
      });

      // Fill other fields
      let fieldsFilled = 0;
      let fieldsSkipped = 0;
      let fieldsError = 0;
      
      fields.forEach(field => {
        const fieldName = field.getName();
        const fieldNameLower = fieldName.toLowerCase();
        
        if (fieldNameLower.includes('roster') && 
            (fieldNameLower.includes('player') || fieldNameLower.includes('libero') || 
             fieldNameLower.includes('coach') || fieldNameLower.includes('assistant') ||
             fieldNameLower.includes('physio'))) {
          fieldsSkipped++;
          return; // Already handled above
        }

        const fieldType = field.constructor.name;

        try {
          // Handle checkboxes (actual PDFCheckBox type)
          if (fieldType === 'PDFCheckBox') {
            let shouldCheck = false;
            if (fieldNameLower.includes('championship') && matchData.match?.matchType === 'championship') {
              shouldCheck = true;
            } else if (fieldNameLower.includes('cup') && matchData.match?.matchType === 'cup') {
              shouldCheck = true;
            }
            if (shouldCheck) {
              field.check();
              console.log(`Checked checkbox: ${fieldName}`);
              fieldsFilled++;
            } else {
              field.uncheck();
            }
            return;
          }
          
          // Handle text fields ending with _x (they need an "X" written, not checked)
          if (fieldNameLower.endsWith('_x') && fieldType === 'PDFTextField') {
            let shouldWriteX = false;
            if (fieldNameLower.includes('championship') && matchData.match?.matchType === 'championship') {
              shouldWriteX = true;
            } else if (fieldNameLower.includes('cup') && matchData.match?.matchType === 'cup') {
              shouldWriteX = true;
            } else if (fieldNameLower.includes('friendly') && matchData.match?.matchType === 'friendly') {
              shouldWriteX = true;
            } else if (fieldNameLower.includes('tournament') && matchData.match?.matchType === 'tournament') {
              shouldWriteX = true;
            } else if (fieldNameLower.includes('national') && matchData.match?.category === 'national') {
              shouldWriteX = true;
            } else if (fieldNameLower.includes('regional') && matchData.match?.category === 'regional') {
              shouldWriteX = true;
            } else if (fieldNameLower.includes('international') && matchData.match?.category === 'international') {
              shouldWriteX = true;
            } else if (fieldNameLower.includes('men') && matchData.match?.gender === 'men') {
              shouldWriteX = true;
            } else if (fieldNameLower.includes('female') && matchData.match?.gender === 'female') {
              shouldWriteX = true;
            } else if (fieldNameLower.includes('u19') && matchData.match?.ageGroup === 'U19') {
              shouldWriteX = true;
            } else if (fieldNameLower.includes('u17') && matchData.match?.ageGroup === 'U17') {
              shouldWriteX = true;
            } else if (fieldNameLower.includes('u23') && matchData.match?.ageGroup === 'U23') {
              shouldWriteX = true;
            }
            
            if (shouldWriteX) {
              field.setText('X');
              console.log(`Wrote X to field: ${fieldName}`);
              fieldsFilled++;
            } else {
              field.setText(''); // Clear if not matching
            }
            return;
          }

          if (fieldType === 'PDFTextField') {
            let value = '';
            if (fieldNameLower.includes('date') || fieldNameLower.includes('datum')) {
              value = formatDate(matchData.match?.scheduledAt || matchData.match?.date);
            } else if (fieldNameLower.includes('time') || fieldNameLower.includes('zeit')) {
              value = formatTime(matchData.match?.scheduledAt || matchData.match?.time);
            } else if (fieldNameLower.includes('venue') || fieldNameLower.includes('hall') || fieldNameLower.includes('halle')) {
              value = matchData.match?.venue || matchData.match?.hall || '';
            } else if (fieldNameLower.includes('city') || fieldNameLower.includes('stadt')) {
              value = matchData.match?.city || '';
            } else if (fieldNameLower.includes('league') || fieldNameLower.includes('liga')) {
              value = matchData.match?.league || '';
            } else if ((fieldNameLower.includes('game') || fieldNameLower.includes('spiel') || fieldNameLower.includes('game_n')) && 
                       !fieldNameLower.includes('player') && !fieldNameLower.includes('roster')) {
              value = matchData.match?.gameNumber || matchData.match?.externalId || matchData.match?.game_n || '';
            } else if (fieldNameLower.includes('home') && fieldNameLower.includes('team') && 
                       !fieldNameLower.includes('roster') && !fieldNameLower.includes('player')) {
              value = matchData.homeTeam?.name || '';
            } else if (fieldNameLower.includes('away') && fieldNameLower.includes('team') && 
                       !fieldNameLower.includes('roster') && !fieldNameLower.includes('player')) {
              value = matchData.awayTeam?.name || '';
            } else if (fieldNameLower.includes('referee1') || fieldNameLower.includes('referee_1') || 
                       (fieldNameLower.includes('referee') && fieldNameLower.includes('1') && !fieldNameLower.includes('2'))) {
              const ref = matchData.officials?.referee1 || {};
              value = ref ? `${ref.firstName || ''} ${ref.lastName || ''}`.trim() : '';
            } else if (fieldNameLower.includes('referee2') || fieldNameLower.includes('referee_2') || 
                       (fieldNameLower.includes('referee') && fieldNameLower.includes('2'))) {
              const ref = matchData.officials?.referee2 || {};
              value = ref ? `${ref.firstName || ''} ${ref.lastName || ''}`.trim() : '';
            } else if (fieldNameLower.includes('scorer') && !fieldNameLower.includes('assistant')) {
              const scorer = matchData.officials?.scorer || {};
              value = scorer ? `${scorer.firstName || ''} ${scorer.lastName || ''}`.trim() : '';
            } else if (fieldNameLower.includes('assistant') || fieldNameLower.includes('asst')) {
              const asstScorer = matchData.officials?.assistantScorer || {};
              value = asstScorer ? `${asstScorer.firstName || ''} ${asstScorer.lastName || ''}`.trim() : '';
            }
            
            if (value !== '') {
              field.setText(value);
              console.log(`Filled field "${fieldName}": "${value}"`);
              fieldsFilled++;
            }
          }
        } catch (error) {
          console.error(`Error filling field ${fieldName}:`, error);
          fieldsError++;
        }
      });
      
      console.log(`Total fields filled: ${fieldsFilled}, skipped: ${fieldsSkipped}, errors: ${fieldsError}`);

      return pdfDoc;
    }

    function updateButtonStates() {
      const hasData = scoreboardData !== null;
      const hasMapping = fieldMapping !== null;
      document.getElementById('fillBtn').disabled = !(hasData && hasMapping);
      document.getElementById('previewBtn').disabled = !hasData;
    }

    // File input handler
    document.getElementById('jsonFile').addEventListener('change', async (e) => {
      const file = e.target.files[0];
      if (file) {
        const text = await file.text();
        document.getElementById('jsonInput').value = text;
        parseJsonInput();
      }
    });

    // JSON input handler
    function parseJsonInput() {
      const jsonText = document.getElementById('jsonInput').value.trim();
      if (!jsonText) {
        scoreboardData = null;
        updateButtonStates();
        return;
      }

      try {
        scoreboardData = JSON.parse(jsonText);
        
        // Merge additional data if provided
        const additionalText = document.getElementById('additionalData').value.trim();
        if (additionalText) {
          try {
            const additional = JSON.parse(additionalText);
            if (additional.referees) {
              scoreboardData.referees = [...(scoreboardData.referees || []), ...additional.referees];
            }
            if (additional.scorers) {
              scoreboardData.scorers = [...(scoreboardData.scorers || []), ...additional.scorers];
            }
          } catch (e) {
            console.warn('Could not parse additional data:', e);
          }
        }
        
        document.getElementById('output').innerHTML = '<p class="success">✓ JSON parsed successfully!</p>';
        updateButtonStates();
      } catch (error) {
        document.getElementById('output').innerHTML = `<p class="error">Error parsing JSON: ${error.message}</p>`;
        scoreboardData = null;
        updateButtonStates();
      }
    }

    document.getElementById('jsonInput').addEventListener('input', parseJsonInput);
    document.getElementById('additionalData').addEventListener('input', parseJsonInput);

    // Preview button
    document.getElementById('previewBtn').addEventListener('click', () => {
      if (!scoreboardData) return;
      const transformed = transformScoreboardData(scoreboardData);
      document.getElementById('output').innerHTML = `
        <h3>Transformed Data Preview:</h3>
        <pre>${JSON.stringify(transformed, null, 2)}</pre>
      `;
    });

    // Fill PDF button
    document.getElementById('fillBtn').addEventListener('click', async () => {
      if (!scoreboardData || !fieldMapping) {
        document.getElementById('output').innerHTML = '<p class="error">Please provide JSON data and ensure mapping is loaded.</p>';
        return;
      }

      const output = document.getElementById('output');
      output.innerHTML = '<p>Transforming data and filling PDF...</p>';

      try {
        // Transform the data
        const transformedData = transformScoreboardData(scoreboardData);
        
        // Load PDF template
        const templateResponse = await fetch('matchblatt_fillable.pdf');
        if (!templateResponse.ok) {
          throw new Error(`Failed to load PDF template: ${templateResponse.statusText}`);
        }
        const templateBytes = await templateResponse.arrayBuffer();
        
        // Load PDF document
        const PDFDocument = await ensurePdfLib();
        const pdfDoc = await PDFDocument.load(templateBytes);
        
        // Fill the form
        console.log('Starting to fill PDF form...');
        console.log('Transformed data:', transformedData);
        console.log('Field mapping available:', !!fieldMapping);
        
        await fillPdfForm(pdfDoc, fieldMapping, transformedData);
        console.log('Form filled successfully');
        
        // Flatten the form to make it non-fillable (temporarily disabled to debug)
        console.log('Flattening form...');
        try {
          const form = pdfDoc.getForm();
          form.flatten();
          console.log('Form flattened');
        } catch (e) {
          console.warn('Form flattening failed (continuing anyway):', e);
        }
        
        // Save PDF
        const pdfBytes = await pdfDoc.save();
        console.log('PDF saved, size:', pdfBytes.length, 'bytes');
        
        // Download
        const blob = new Blob([pdfBytes], { type: 'application/pdf' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        const homeTeamName = (transformedData.homeTeam?.name || 'Home').replace(/[^a-zA-Z0-9]/g, '_');
        const awayTeamName = (transformedData.awayTeam?.name || 'Away').replace(/[^a-zA-Z0-9]/g, '_');
        const date = transformedData.match?.date || new Date().toLocaleDateString('de-DE').replace(/\//g, '-');
        a.download = `Matchblatt_${homeTeamName}_vs_${awayTeamName}_${date}.pdf`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        
        output.innerHTML = '<p class="success">✓ PDF generated and downloaded successfully!</p>';
      } catch (error) {
        console.error('Error:', error);
        output.innerHTML = `<p class="error">Error: ${error.message}</p><pre>${error.stack}</pre>`;
      }
    });

    // Extract PDF fields button
    document.getElementById('extractBtn').addEventListener('click', async () => {
      const output = document.getElementById('extractOutput');
      output.innerHTML = '<p>Loading PDF and extracting fields...</p>';
      
      try {
        // Ensure PDF-lib is loaded first
        const PDFDocument = await ensurePdfLib();
        
        const response = await fetch('matchblatt_fillable.pdf');
        if (!response.ok) {
          throw new Error(`Failed to load PDF: ${response.statusText}`);
        }
        const arrayBuffer = await response.arrayBuffer();
        
        const pdfDoc = await PDFDocument.load(arrayBuffer);
        const form = pdfDoc.getForm();
        const fields = form.getFields();
        
        const extractedFields = [];
        const fieldGroups = {
          players: { home: { dob: [], number: [], name: [] }, away: { dob: [], number: [], name: [] } },
          liberos: { home: { dob: [], number: [], name: [] }, away: { dob: [], number: [], name: [] } },
          bench: { home: {}, away: {} }
        };
        const checkboxes = [];
        const dates = [];
        
        fields.forEach(field => {
          const fieldName = field.getName();
          const fieldType = field.constructor.name;
          const nameLower = fieldName.toLowerCase();
          
          extractedFields.push({ name: fieldName, type: fieldType });
          
          if (fieldType === 'PDFCheckBox' || nameLower.endsWith('_x')) {
            checkboxes.push(fieldName);
          }
          if (nameLower.includes('date') || nameLower.includes('dob') || nameLower.includes('datum')) {
            dates.push(fieldName);
          }
          
          // Categorize fields
          if (nameLower.includes('roster') && nameLower.includes('player')) {
            if (nameLower.includes('home')) {
              if (nameLower.includes('dob')) fieldGroups.players.home.dob.push(fieldName);
              else if (nameLower.includes('number')) fieldGroups.players.home.number.push(fieldName);
              else if (nameLower.includes('name')) fieldGroups.players.home.name.push(fieldName);
            } else if (nameLower.includes('away')) {
              if (nameLower.includes('dob')) fieldGroups.players.away.dob.push(fieldName);
              else if (nameLower.includes('number')) fieldGroups.players.away.number.push(fieldName);
              else if (nameLower.includes('name')) fieldGroups.players.away.name.push(fieldName);
            }
          } else if (nameLower.includes('roster') && nameLower.includes('libero')) {
            if (nameLower.includes('home')) {
              if (nameLower.includes('dob')) fieldGroups.liberos.home.dob.push(fieldName);
              else if (nameLower.includes('number')) fieldGroups.liberos.home.number.push(fieldName);
              else if (nameLower.includes('name')) fieldGroups.liberos.home.name.push(fieldName);
            } else if (nameLower.includes('away')) {
              if (nameLower.includes('dob')) fieldGroups.liberos.away.dob.push(fieldName);
              else if (nameLower.includes('number')) fieldGroups.liberos.away.number.push(fieldName);
              else if (nameLower.includes('name')) fieldGroups.liberos.away.name.push(fieldName);
            }
          }
        });
        
        // Sort by row number if available
        ['home', 'away'].forEach(team => {
          ['dob', 'number', 'name'].forEach(fieldType => {
            fieldGroups.players[team][fieldType].sort((a, b) => {
              const numA = a.match(/_(\d+)$/)?.[1] || 0;
              const numB = b.match(/_(\d+)$/)?.[1] || 0;
              return parseInt(numA) - parseInt(numB);
            });
            fieldGroups.liberos[team][fieldType].sort((a, b) => {
              const numA = a.match(/_(\d+)$/)?.[1] || 0;
              const numB = b.match(/_(\d+)$/)?.[1] || 0;
              return parseInt(numA) - parseInt(numB);
            });
          });
        });
        
        const mapping = {
          metadata: {
            extractedAt: new Date().toISOString(),
            totalFields: extractedFields.length,
            pdfFile: 'matchblatt_fillable.pdf'
          },
          fieldMappings: {},
          fieldTypes: {},
          specialFields: {
            checkboxes: checkboxes,
            dates: dates,
            playerRosters: [],
            liberoRosters: []
          },
          fieldGroups: fieldGroups
        };
        
        extractedFields.forEach(field => {
          let dataType = 'string';
          if (checkboxes.includes(field.name)) dataType = 'checkbox';
          else if (dates.includes(field.name)) dataType = 'date';
          else if (field.name.toLowerCase().includes('number')) dataType = 'number';
          else if (field.name.toLowerCase().includes('time')) dataType = 'time';
          
          mapping.fieldMappings[field.name] = {
            pdfType: field.type,
            dataType: dataType
          };
          mapping.fieldTypes[field.name] = dataType;
        });
        
        // Store mapping
        fieldMapping = mapping;
        
        // Download mapping file
        const blob = new Blob([JSON.stringify(mapping, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'pdf-field-mapping.json';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        
        output.innerHTML = `
          <p class="success">✓ Extracted ${extractedFields.length} fields!</p>
          <p>Checkboxes: ${checkboxes.length}</p>
          <p>Date fields: ${dates.length}</p>
          <p>Player roster fields (home): ${fieldGroups.players.home.dob.length} rows</p>
          <p>Player roster fields (away): ${fieldGroups.players.away.dob.length} rows</p>
          <p>Libero fields (home): ${fieldGroups.liberos.home.dob.length} rows</p>
          <p>Libero fields (away): ${fieldGroups.liberos.away.dob.length} rows</p>
          <p>Mapping file downloaded! You can now fill the PDF.</p>
        `;
        updateButtonStates();
      } catch (error) {
        console.error('Error extracting fields:', error);
        output.innerHTML = `<p class="error">Error: ${error.message}</p>`;
      }
    });

    // Load mapping on page load (optional - will try to load existing file)
    loadFieldMapping();
  </script>
</body>
</html>

